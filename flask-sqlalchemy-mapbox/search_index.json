[
["index.html", "Building Python-based, database-driven web applications (with maps!) using Flask, SQLite, SQLAlchemy and MapBox 1 Preface 1.1 Our goal 1.2 Every step we’ll take 1.3 Why in the name of undiscovered species am I doing this?", " Building Python-based, database-driven web applications (with maps!) using Flask, SQLite, SQLAlchemy and MapBox Jonathan Soma 2019-06-17 1 Preface 1.1 Our goal All right, crew, we’re going to build a web application, which is a fancy way of saying “web site that talks to a database.” Except that isn’t necessarily true, as it might also just mean “a fancy web site.” But we’re pretending it’s approximately 2012 and that’s still what a web application mostly is, because the world’s too confusing as it is. 1.2 Every step we’ll take Our steps are going to look something like this: Set up a little website that doesn’t do much at all Take some data from a CSV and put it into a little database Connect our little website to our little database Make the website reflect what’s in the database (so if you update the database, you update the website!) Add some cool maps to our website so people know we mean business Add all other sorts of miscellaneous bells and whistles to our website, too(t toot)** ** That’s a solid joke about a whistle 1.3 Why in the name of undiscovered species am I doing this? Usually when you get a big ol’ set of data you need to analyze it. Take various types of averages, look at distributions, stuff like that. Sometimes, though, it’s more important to browse. For example: It’s nice to know that in theory some surgeons are good and some surgeons are bad, but it’s more useful to know which surgeons are good and which surgeons are bad. And thanks to ProPublica’s Surgeon Scorecard, we can do a little searching and figure out exactly how the landscape looks! Typically you end up with an automatically-generated web page for every single item in your database - whether it’s a doctor, or a school, or a company. That page can list all of the sorts of data that’s hiding in your database about that doctor, school, or company… but in a nice friendly that’s palatable to people who are allergic to Excel et al. And with charts, even!!! Or maps!!! You aren’t restricted to showing that single item, either - you should show related schools, compare the selected doctor to others others nearby, or contextualize a company’s earnings based on the earnings of all other companies in your database. Any comparative analysis you could do piece-by-piece you can code to display automatically on your web page! "],
["getting-started-with-flask.html", "2 Getting started with Flask 2.1 Baby’s first web app 2.2 Template time 2.3 Adding CSS", " 2 Getting started with Flask We’re going to start by firing up a basic, no-frills web application using Flask. Flask is a web application framework, which means it does all the complicated parts of building a website and leaves you with the easy bits (relatively speaking). That definitely doesn’t make any sense right now, but that’s perfectly fine, because you’re about to see how it works! 2.1 Baby’s first web app Make a new, empty folder. Add a new file in it called app.py that contains the following code: # app.py from flask import Flask app = Flask(__name__) @app.route(&quot;/&quot;) def hello(): return &quot;Hello World!&quot; if __name__ == &#39;__main__&#39;: app.run(debug=True) Welcome to your web app! Run it with python app.py. You might need to pip install flask before this bad boy will run. Your terminal will do…. something? Nothing? In order to see the real magic, visit http://localhost:5000. Or http://127.0.0.1:5000! Tada! it’s a web server, sending out a web site, just like Amazon or Geocities or whatever, except it’s running on your computer and only you can see it. Both localhost and 127.0.0.1 mean “your own computer,” and the 5000 is the port. If the IP address is the address of your computer in the world, the port is like a room number. If something is hanging out in room 8888 (Jupyter notebook!), no one else can stay in there. Flask uses 5000 because it thinks hey, no reason not to. If something else was using 5000 Flask would panic and not work (there’s nowhere for it to stay, after all). You could change it by doing app.run(debug=True, port=5001) or whatever else you wanted, but for now let’s be satisfied with the basics. It’s pretty boring, though, and it only works for one URL. If you tried to go to http://localhost:5000/shoelaces, you’d get a Not Found error, just like if you tried to visit a web page on the Internet that doesn’t work. 2.1.1 Servers up servers down If you were paying attention to your Terminal, you might have noticed that every time you refresh your page, it prints out a new line. 127.0.0.1 - - [13/Jun/2019 19:19:15] &quot;GET / HTTP/1.1&quot; 200 127.0.0.1 - - [13/Jun/2019 19:25:09] &quot;GET /shoelaces HTTP/1.1&quot; 404 That’s Flask spitting out debugging information, just in case there’s an error. The 200 means everything went okay, while 404 means that it couldn’t find that page. Go ahead and try to type something in that window, like a nice ls or pwd…. it won’t work! That’s because Python/Flask is busy being in charge of that command line now, and the program won’t stop running until you hold down the control key and press C, aka Ctrl+C. Go ahead and Ctrl+C your way out of the Python app. You’re back at the command line now! If you try to refresh your web site at http://localhost:5000/, you’ll also see it’s totally broken and doesn’t work at all now. That’s because your server is down! Before we turn it back on, let’s make a little adjustment to our app.py. Let’s help it support that /shoelaces URL we were talking about before: # app.py from flask import Flask app = Flask(__name__) @app.route(&quot;/&quot;) def hello(): return &quot;Hello World!&quot; @app.route(&quot;/shoelaces&quot;) def shoelaces(): return &quot;This works now!&quot; if __name__ == &#39;__main__&#39;: app.run(debug=True) Restart your server by running python app.py again, then visit http://localhost:5000/shoelaces again. Hooray! Success! 2.1.2 Routing in Flask The code we added looked like this: @app.route(&quot;/shoelaces&quot;) def shoelaces(): return &quot;This works now!&quot; This is called a route, it’s basically a URL where your web server has agreed to listen to. If you know about APIs, maybe you could call it an endpoint! When someone visits /shoelaces, Flask runs the code underneath, and shows This works now! to whoever is on the page. If you’re confused by the @app or the def or any of that, don’t worry, it seriously doesn’t matter. There’s only one and a half rule: When you add a new route, you add an app.route, but you also need to change the name of the def part. When we added the /shoelaces route, we mostly re-used the code from above (the def and the return), but we renamed def hello to be def shoelaces. Let’s compare them: @app.route(&quot;/&quot;) def hello(): return &quot;Hello world!&quot; @app.route(&quot;/shoelaces&quot;) def shoelaces(): return &quot;This works now!&quot; They both have different routes, and they both have different def names. Looks safe! If you re-use one of those names, your app will break! So please try not to. 2.1.3 Here we go again Try adding one more route, this one can be called /about. Mine is going to look like this: @app.route(&quot;/about&quot;) def about(): return &quot;All about my website!&quot; Visit http://localhost:5000/about, and voila! Perfect, simple, magic. You added a new route, you added a new page, you added a little bit of beauty to the internet. Well, not the internet, actually! This web server only exists on your machine, and no one outside of your machine can access it. We’ll figure out how to put it online later, sorry if you were hyped to be the next MySpace. 2.2 Template time I’m going to tell you a secret, if you promise to keep it to yourself: our web site sucks. Like, real bad. We’re barely going to break the top 100 in Alexa with this, so we’re going to have to do some bigtime fixing-up. Right now our website can only say words. Let’s change our / route (our root) to say something else when you visit the page, someting that looks weird: @app.route(&quot;/&quot;) def hello(): return &quot;&lt;h1&gt;Do you like big text?&lt;/h1&gt;&lt;p&gt;I&#39;m ambivalent but accepting&lt;/p&gt;&quot; Visit http://localhost:5000/ again and be amazed. Or not! If your web site stops working, don’t worry. Flask likes to quit runnning your server if you accidentally save Python code that has an error. Just check your command line, you probably just need to re-run python app.py. 2.2.1 Bringing structure to this world What we did was add HTML to our web page. HTML is the language that web pages are made out of! If you love pedantry, we’re about to hit a great fact: HTML is a language computers use, but it isn’t a programming language! HTML is a markup language - it’s right there in the name, HyperText Markup Language - and it’s used to describe what the different elements on a page are. &lt;h1&gt; means “real important header” and &lt;h2&gt; means “less important header” and &lt;p&gt; means “paragraph” and so on and so forth. You can add other web-friendly languages to make your pages fancier - CSS to make them pretty and JavaScript to make them interactive - but for the next uh ten seconds or so we’ll ignore that they exist and love our ugly ugly page. The biggest problem at the moment is that we probably want to write more than just those two lines on our page. Maybe we want like ten lines on our page, right? Sixty lines? And if we do, it’s going to be a royal pain to type all that out in one single Python string. Is there a solution, hiding somewhere out in the world? Of course there is! We’re going to move them into a different file. Creat a new folder call templates. And another one called static, while we’re at it! Put a new empty file called index.html in your templates folder. It can live an alone, empty life for a second, I promise it’ll improve in a bit. Your folder structure should look like this: app.py static/ templates/ index.html 2.2.2 Template time Now we’re going to set up our route to use that template. First step, import a little function that will allow us to talk to the template. Edit app.py to add a new import to the top of the file: # app.py from flask import Flask from flask import render_template And now let’s use it - we’ll edit our / route again, but this time we’re going to point it to that index.html file. @app.route(&quot;/&quot;) def hello(): return render_template(&quot;index.html&quot;) Refresh http://localhost:5000/ and see your grand, beautiful page: ….it’s empty! You if you check the command line running Flask, you’ll see that it’s printed 200, which means everything worked. We forgot one thing, though: adding content into our template! Edit index.html to look like this: &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;My incredible web site.&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;This is a REAL WEB PAGE.&lt;/h1&gt; &lt;h3&gt;It&#39;s pretty cool.&lt;/h2&gt; &lt;p&gt;I&#39;m amazed and frankly you should be, too.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; Refresh again! Beautiful, beautiful, beautiful. 2.3 Adding CSS It isn’t actually beautiful, but let’s not be too harsh on ourselves. We aren’t designers! We just have to take what the browser gives us and accept it as a cruel reality. …or do we? We aren’t designers, but luckily, other people are. And not only are the designers, but they’ve designed things and released them for us to use. With one line of code we’re going to add their ways of styling a page to our amazing, beautiful website to make it even more amazing and beautiful. 2.3.1 Hello Bootstrap! We’re going to be using Bootstrap, which is an incredibly popular and incredibly overwraught, heavyweight piece of overengineering. But like I said, it’s popular, so we don’t have any right to judge it (I guess?). &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;My incredible web site.&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;This is a REAL WEB PAGE.&lt;/h1&gt; &lt;h3&gt;It&#39;s pretty cool.&lt;/h3&gt; &lt;p&gt;I&#39;m amazed and frankly you should be, too.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; Okay, actually it isn’t that beautiful yet, our font just changed a bit. We need to give it a little nudge to beautify it… &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;My incredible web site.&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;nav class=&quot;navbar navbar-expand-lg navbar-dark bg-dark&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;An incredible site&lt;/a&gt; &lt;/nav&gt; &lt;div class=&quot;jumbotron&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1 class=&quot;display-4&quot;&gt;This is a &lt;strong&gt;real web page&lt;/strong&gt;.&lt;/h1&gt; &lt;p class=&quot;lead&quot;&gt;It&#39;s pretty cool.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt;I&#39;m amazed and frankly you should be, too.&lt;/p&gt; &lt;p&gt;Look at this stuff!!! Incredible.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; Okay, maybe more than a nudge, but that’s just how Bootstrap works: mostly well, and painfully. But you’ll get mostly used to it, I promise (or you’ll go use something nice like bulma instead). 2.3.2 What now? Now that we have a somewhat cool website, we need some content to put on that site. Yeah, we could set up templates for about and shoelaces or whatever, but that’s a waste of time at the moment. We need some stuff! So let’s take a break from the web and dance on over to database land, where we’ll learn to put together the database that’s going to power our site. "],
["setting-up-our-database.html", "3 Setting up our database 3.1 Intro to SQLite 3.2 Creating a new SQLite database", " 3 Setting up our database When you’re Serious About Data (which we are, of course), you store your data in a database, not an Excel spreadsheet or CSV file. They’re faster and more flexible, even if you use a terrible baby database format like we’re going to use. 3.1 Intro to SQLite Our database is going to be a SQLite database, which is perfect and wonderful because it’s just a file. If I want to send you my database, I can just send it to you via email or Dropbox or whatever - no playing around with installing things or servers or anything like this. It’s not the best database by any means, but it’s easy! Think of it like a small upgrade to a CSV file. If you want to put something on the web, you’re welcome to use any kind of database you’d like. We’re going to use TablePlus to manage our data, and feel free to connect to a PostgreSQL instance or a MySQL server or anything else you’d like if that’s more your speed. 3.2 Creating a new SQLite database To create our new SQLite database, we’re going to start with a CSV file. We’re going to use this one, which is a list of schools in New York City. Download it and save it to the same directory as app.py. To create a new SQLite database from your CSV file, you’re mostly going to follow these instructions, except database creation is a little different: Select SQLite after clicking Create a new connection. Type schools in Name. This is the nickname TablePlus will refer to it by. Click Select database, pick your folder that app.py is in. When it asks for a name, say schools again. This will be the name of the actual database file. Then click Create Now begin the import using File &gt; Import &gt; From CSV…. Make sure create new table and first line is header are both checked, then complete the rest: Most of the data types should be okay, but… Change the very first column - the numbered one without a name - to have the column type Do not import Change the following columns to be text: ZIP, block, county_fips, state_fips, tract, zipcode (sorry, I didn’t clean this up after I converted addresses into lat/lon) Also select the ‘City’ and address column types to Do not import (we already have an ADDRESS and city which are the same!) When you’re reasonably confident you’ve done it all correctly, click Import. Give it a minute to process, TablePlus can be a little awkwardly slow sometimes. It’s pretty, though, so we’ll trust it. 3.2.1 Double-checking the import Once it looks like you’re done, briefly double-check that everything imported correctly by click the Refresh icon at the top of the screen. You should see the schools-geocoded table appear on the left-hand pane of TablePlus. Click it and you should see the center pane fill up with schools! You’ll always forget to click Refresh. Constantly. Every day. And you’ll be confused, every time, wondering where your data is. Every second, always forgetting to click refresh. Don’t forget! Now it’s time to take our incredible database and connect it to our incredible website. Let’s go! "],
["connecting-flask-to-sqlite.html", "4 Connecting Flask to SQLite 4.1 Speaking SQL 4.2 Introduction to ORMs 4.3 Using SQLAlchemy", " 4 Connecting Flask to SQLite Now that we have our Flask app kind of set up and our SQLite database ready to go, it’s time to make them talk to each other. 4.1 Speaking SQL If you’ve used things like sqlite3 or pg8000 to talk to databases before, you know it can really be a pain to wrangle your data. It’s even worse when working with Flask. Brace yourself and take a look at this awesome “simple example of how you can use SQLite 3 with Flask” DATABASE = &#39;/path/to/database.db&#39; def get_db(): db = getattr(g, &#39;_database&#39;, None) if db is None: db = g._database = sqlite3.connect(DATABASE) return db @app.teardown_appcontext def close_connection(exception): db = getattr(g, &#39;_database&#39;, None) if db is not None: db.close() Oof, eef, aaf, this “simple example” it hurts parts of my body I didn’t even know I had. And then under the header “Easy Querying” it shows you this real baller piece of work: def make_dicts(cursor, row): return dict((cursor.description[idx][0], value) for idx, value in enumerate(row)) db.row_factory = make_dicts Dear Reader, my Sweet Friend, that’s horrible. That’s a fate worse than ten or twenty unimaginable terrors. So we ain’t gonna do it. We’re gonna do something else. We’re gonna do something better. 4.2 Introduction to ORMs Once upon a time there were databases, and there was SQL, and there were people who loved writing SQL. SQL is cool, SQL is great! Then everyone else was invented, and they didn’t like writing SQL, they just liked writing Python. So the Gods invented ORMs, which basically mean “instead of writing SQL you’ll just write Python and the ORM will talk to the database for you.” Now everyone can be happy! ORM means Object-relational mapping, which doesn’t mean anything to anyone and no one will ever ask you about that There are a handful of ORMs that work for Python, and plenty that work with Flask. Peewee is one that’s pretty simple to get running with, but it isn’t as popular as SQLAlchemy. SQLAlchemy is… an acquired taste, but it’s very popular, and because it’s so popular I am absolutely certain that my distaste for SQLAlchemy is because I’m too stupid to understand it**, so we’re going to use it for this example. ** Ever since I was a little baby I was programming in a language called Ruby and using an ORM called ActiveRecord. Ruby is a lot like Python, but ActiveRecord is not like SQLAlchemy: ActiveRecord is a beautiful angel sent from heaven to cure the world of all ills. The world - sadly, predictably - just doesn’t listen. 4.2.1 Setting up SQLAlchemy First, before we even look at SQLAlchemy, let’s install a lil’ package that will connect SQLAlchemy to Flask. It’s called - wait for it! - flask_sqlalchemy. Install as such: pip install flask_sqlalchemy It’ll also automatically install SQLAlchemy itself. To use it in our app, you’ll also need to add the appropriate import. At the top of app.py, near where you’re importing all the Flask bits and pieces, add the following: # app.py from flask import Flask from flask import render_template from flask_sqlalchemy import SQLAlchemy Standard workhorse stuff, nothing too crazy. 4.2.2 Adding our Model Now the real work begins! We need to define our Model, which is the Python version of our SQL table. Every table gets a model, and we use that model to play around with its associated table from Python. (Although we only have one table in this case, so we’ll only have one model) Going back to our code - right after we make our Flask app with app = Flask(__name__), you’ll want to tell SQLAlchemy everything important about the database and its tables. It’ll look like this: app = Flask(__name__) app.config[&#39;SQLALCHEMY_DATABASE_URI&#39;] = &#39;sqlite:///schools.sqlite3&#39; db = SQLAlchemy(app) db.Model.metadata.reflect(db.engine) class School(db.Model): __tablename__ = &#39;schools-geocoded&#39; __table_args__ = { &#39;extend_existing&#39;: True } LOC_CODE = db.Column(db.Text, primary_key=True) Let’s take it line-by-line to get an idea of what’s going on (or a-few-lines by a-few-lines). First off, you tell the app where to find the database and initialize SQLAlchemy: app.config[&#39;SQLALCHEMY_DATABASE_URI&#39;] = &#39;sqlite:///schools.sqlite3&#39; db = SQLAlchemy(app) Usually when you’re working with SQLAlchemy, you have to make a nice long list of every column in the table, and whether it’s an integer, text, float, whatever. This table has about sixteen thousand rows, so you’d probably perish from old age before we finished up. Luckily, there’s an option to tell SQLALchemy that we’re way too lazy to do that, and for every model it should just look at the columns that already exist in the table. This is called reflecting! To tell SQLAlchemy we’re lazy and it should teach itself about the database, we use this line: db.Model.metadata.reflect(db.engine) It’s always the same, never changes. A million tables, weird names, etc etc, nothing affects it. If you don’t want to list all those columns out, you’ll be using that line. Now we’re finally ready to make the model!!!!! We need to tell the model four things: Its name. In this case, we’re calling it School, because it’s… a list of schools. The table name to both find the data in and to learn the columns from. That’s schools-geocoded, because TablePlus took the name right from the CSV file and didn’t give us any other choice. A weird line about extend_existing, which is always exactly the same. It just means “hey, we’re going to change something about the table,” because… …even though it learn the columns by reflecting, SQLAlchemy needs a unique column to be able to keep each row separate, like an id. In this case, it’s the LOC_CODE column. This is called the “primary key.” That final bit of code all together looks like this: class School(db.Model): __tablename__ = &#39;schools-geocoded&#39; __table_args__ = { &#39;extend_existing&#39;: True } LOC_CODE = db.Column(db.Text, primary_key=True) Give your page a refresh to make sure you don’t have any typos or other little issues, and then we’ll charge ahead to actually using this model. 4.3 Using SQLAlchemy We don’t know how to make our database talk to the web page yet, so we’re going to cheat a little bit. Let’s edit the /about route to make it print something out: @app.route(&quot;/&quot;) def hello(): print(&quot;Total number of schools is&quot;, School.query.count()) return render_template(&quot;index.html&quot;) Refresh the page and you’ll see…. nothing changed? But pop on over to your command line, and you’ll see a secret little line hiding in the debug output: Total number of schools is 1640 127.0.0.1 - - [13/Jun/2019 23:41:07] &quot;GET / HTTP/1.1&quot; 200 - When you use print in the Flask app, it doesn’t print to the web page. That’s the render_template part. Instead, print prints to the command line. It’s totally useless for showing things to the user, but a nice cheat to check things and help us debug. Where’d that 1640 come from? School.query.count()! We used our model - School - to visit the database, build a new query, and count the number of rows in the table. That’s not SQL, right? The SQL would be something like this: SELECT COUNT(*) FROM `geoceoded-schools` But because we’re using an SQLAlchemy, we write Python, not SQL. SQLAlchemy takes care of the translation to SQL and just gives us the result. For example, we can do a WHERE query - filtering our data - by using filter_by. It might like this: &gt;&gt;&gt; peter = User.query.filter_by(username=&#39;peter&#39;).first() &gt;&gt;&gt; peter.id 2 &gt;&gt;&gt; peter.email &#39;peter@example.org&#39; You can find more examples in the documentation. To play around a little, let’s try to find a specific school and print out its name. @app.route(&quot;/&quot;) def hello(): print(&quot;Total number of schools is&quot;, School.query.count()) school = School.query.filter_by(LOC_CODE=&#39;X270&#39;).first() print(&quot;School&#39;s name is&quot;, school.SCHOOLNAME) return render_template(&quot;index.html&quot;) Refresh the page, check the terminal to see the output of your print statements. Should look something like this: * Debugger PIN: 897-623-853 Total number of schools is 1640 School&#39;s name is ACADEMY FOR SCHOLARSHIP AND ENTREPRENEURSHIP: A CO 127.0.0.1 - - [13/Jun/2019 23:50:07] &quot;GET / HTTP/1.1&quot; 200 - What comes back from the database is that one row where LOC_CODE='X270' - we only got one because we asked for .first(). It works just like a normal variable, kind of like a dictionary that you don’t need ['whatever'] for. Instead, you can just ask for each column with a period. Since SCHOOLNAME is the column with the school’s name in it, we can just ask for school.SCHOOLNAME and it will print right out. If we want to get fancier, we can also select multiple rows with .all(). @app.route(&quot;/&quot;) def hello(): print(&quot;Total number of schools is&quot;, School.query.count()) school = School.query.filter_by(LOC_CODE=&#39;X270&#39;).first() print(&quot;School&#39;s name is&quot;, school.SCHOOLNAME) zip_schools = School.query.filter_by(ZIP=&#39;10466&#39;).all() for zip_school in zip_schools: print(zip_school.SCHOOLNAME) return render_template(&quot;index.html&quot;) Since we asked for .all() what comes back is similar to a list. That means we need to use a loop if we want to print all their names out, with the same .SCHOOLNAME technique to get the value from the SCHOOLNAME column. The results are nice and long: Total number of schools is 1640 School&#39;s name is ACADEMY FOR SCHOLARSHIP AND ENTREPRENEURSHIP: A CO P.S. 087 BRONX P.S. 103 HECTOR FONTANEZ P.S. 068 BRONX ACADEMY FOR SCHOLARSHIP AND ENTREPRENEURSHIP: A CO NEW WORLD HIGH SCHOOL SPORTS PROFESSIONS HIGH SCHOOL P.S. 021 PHILLIP H. SHERIDAN J.H.S. 142 JOHN PHILIP SOUSA Baychester Middle School One World Middle School at Edenwald P.S. 111 SETON FALLS BRONX CHARTER SCHOOL FOR BETTER LEARNING P.S. 112 BRONXWOOD BAYCHESTER ACADEMY 127.0.0.1 - - [13/Jun/2019 23:53:23] &quot;GET / HTTP/1.1&quot; 200 - And that’s how an ORM works! Kind of, partially, somewhat, anyway. Yes, we have to memorize a new weird set of ways to do things (why did WHERE become filter_by?), but I promise working with SQL in Python is a tiny pile of ashes we don’t want to play in. 4.3.0.1 Ready to go? We’ve been flexing our sweet new SQLAlchemy ORM, testing our skills at querying and counting and WHEREing without WHEREs, but how about we actually make this useful? In the next section we’ll take a look at how we can put this data on the actual web page. "],
["putting-data-on-the-page.html", "5 Putting data on the page 5.1 Sending data to the template 5.2 Hello Jinja2 5.3 Sending meaningful data to the template 5.4 Sending lists to our template 5.5 Making school pages 5.6 Linking from the index to the detail page 5.7 Reusing templates 5.8 Cleaning up", " 5 Putting data on the page So far we’ve touched a lot of new technology! This might cover most of it: Flask, a Python web application framework HTML to draw a page, through the render_template method CSS via Bootstrap to beautify our web page SQLite, our database system SQLAlchemy, our ORM But fret not, we’re not done! We still have at least one more: a templating engine called Jinja, to help us add data from our database onto our web page. 5.1 Sending data to the template Right now when we call render_template, all we give it is the name of the template. If we cut out the ORM practice, our / route looks pretty simple: @app.route(&quot;/&quot;) def hello(): # ....ignoring the ORM practice .... return render_template(&quot;index.html&quot;) Turns out we can level things up by sending additional information to the template! Let’s say we wanted to send the number of schools to the web page, and we guessed it was around 900 schools. We could adjust the render_template call like this: @app.route(&quot;/&quot;) def hello(): # ....ignoring the ORM practice .... return render_template(&quot;index.html&quot;, count=90) count is just a new variable name, it could be anything. potato, bubblegum, you could pick just about any variable name in there and you’d be fine. By count count=90 with render_template, we’re sending a variable called count to the template. Now we just need to figure out how to use it! Let’s go back to the template - templates/index.html - and make a little edit. &lt;div class=&quot;jumbotron&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1 class=&quot;display-4&quot;&gt;There are {{ count }} schools in New York City.&lt;/h1&gt; &lt;p class=&quot;lead&quot;&gt;It&#39;s pretty cool.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; Refresh the page and be amazed! That incredibly fake and contrived 90 wormed its way from the Python side of things to the HTML side of things without too much trouble. 5.2 Hello Jinja2 That {{ count }} thing is not HTML. Before Flask sends the web page to your browser, it goes through the page and finds things like {{ count }} and fills it in with variable names. This is a templating language called Jinja2. It can do a lot more than fill-in-the-blanks, including loops and all sorts of stuff. It’s super useful and an odd combination of painless and painful. You’ll enjoy it! The double-curly-braces thing - {{ }} - is pretty common across different templating languages. Sometimes you might hear them referred to as “mustaches,” thanks to mustache.js and the later handlebars.js. They might look similar to Jinja2, but don’t get distracted! Just think “oh mustaches sure ok” and move on with life. 5.3 Sending meaningful data to the template This fake 90 is killin me, so lets’s adjust our app.py to send the actual number of schools. I’m going to cruelly ignore the print statements we added before (feel free to comment them out!). @app.route(&quot;/&quot;) def hello(): school_count = School.query.count() return render_template(&quot;index.html&quot;, count=school_count) Beautiful! Wonderful! Incredible! You might be tempted to do the ORM query inside of render_template, like this: return render_template(&quot;index.html&quot;, count=School.query.count()) While this works, it just seems a little messy to me. Saving the count as another variable doesn’t kill anyone (I don’t think), and it’s potentially more organized if you end up sending more variables to the template. 5.3.1 Formatting your numbers While “1640” is pretty ugly, “1,640” looks a little more solid. If we wanted to add commas, we could do it one of two ways. The second way is probably better, but the first one uses f-strings! Crises, crises. In the first way, we add the commas before it goes to the template. @app.route(&quot;/&quot;) def hello(): school_count = f&quot;{School.query.count():,}&quot; return render_template(&quot;index.html&quot;, count=school_count) So instead of sending an actual count to the template, we’re sending the pretty, comma-ful version. If we’re doing math in the template that’s a bad idea, but… maybe it’s fine otherwise? Another option is to do the formatting in the template. Since Jinja is a Python thing, you can do Python things inside of the {{ }}………except f-strings! If we want to use Python’s string formatting, we need to do it with a slightly older style: &lt;div class=&quot;jumbotron&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1 class=&quot;display-4&quot;&gt;There are {{ &quot;{:,}&quot;.format(count) }} schools in New York City.&lt;/h1&gt; &lt;p class=&quot;lead&quot;&gt;It&#39;s pretty cool.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; This is probably the better way, as you’re preserving the formatting rules until exactly when you’re formatting it. If you love f-strings to death, though, it might give you a heart attack, so I figured I’d give you another option. 5.4 Sending lists to our template Sending a single integer to our template is pretty easy, but so is sending a whole mess of things! Let’s send those schools we found, the ones from the 10466 ZIP code. @app.route(&quot;/&quot;) def hello(): school_count = f&quot;{School.query.count():,}&quot; zip_schools = School.query.filter_by(ZIP=&#39;10466&#39;).all() return render_template(&quot;index.html&quot;, count=school_count, schools=zip_schools) Adding schools=zip_schools sends another variable to our template. In the template, the variable will be called schools, but it will have the contents of the zip_schools variable. Now all we need to do is display them! Over in HTML world, printing them is a little different than when we did the {{ count }}. Because there are multiples, we need a loop. Loops in Jinja2 are reasonably different than Python, but you’ll get the gist. We’ll put these down near the bottom, replacing Look at this stuff!!!: &lt;div class=&quot;container&quot;&gt; &lt;p&gt;I&#39;m amazed and frankly you should be, too.&lt;/p&gt; {% for school in schools %} &lt;p&gt;{{ school.SCHOOLNAME }}&lt;/p&gt; {% endfor %} &lt;/div&gt; Refresh, and you should be good to go! If not, make sure you matched up the variable names - schools=zip_schools and {% for school in schools %}. Also check that you used {% %} instead of { }. In the same way that in app.py we used school.SCHOOLNAMEto grab theSCHOOLNAMEcolumn, we can do the same thing in the template. Anything you send throughrender_template` you’re free to use in the HTML side of things! Remember that SQLALchemy is not like pandas, and you only get to use one item at a time! schools.SCHOOLNAME will not give you the name for every single school, you’ll need to use a loop like a normal list. 5.5 Making school pages 5.5.1 Slugs Back in historical times when we first talked about webapps, we described them like this: Typically you end up with an automatically-generated web page for every single item in your database - whether it’s a doctor, or a school, or a company. That page can list all of the sorts of data that’s hiding in your database about that doctor, school, or company… but in a nice friendly that’s palatable to people who are allergic to Excel et al. When you have these pages - we’ll call them “show” or “detail” pages - they need to live at a specific URL. If example.com has a list of states, you might click one to be send to the individual state detail page at one of the following: example.com/states/2 example.com/states/WA example.com/states/washington example.com/states-WA The little bit at the end - the 2 or the WA or the washington, etc - is called the id or the slug. Practically speaking, the slug is how the webapp finds the state you’re interested in from the database. We have a few options about what we could use for a slug, it just needs to be something unique for each row of our dataset. For example, every school has a different name! But if we used school name as the slug, we’d end up with: http://example.com/schools/RIVERDALE / KINGSBRIDGE ACADEMY (MIDDLE SCHOOL / H which doesn’t look exactly professional. An easy out is to use whatever the primary_true is in your database - it’s guaranteed to be unique, so each row in your database has a separate one. It might not be the most attractice, but it’s easy! In our case, we set the primary_key in the last line of our model: class School(db.Model): __tablename__ = &#39;schools-geocoded&#39; __table_args__ = { &#39;extend_existing&#39;: True } LOC_CODE = db.Column(db.Text, primary_key=True) There we go, LOC_CODE! So the Riverdale school we mentioned up above would be found at http://example.com/schools/X141 Which is a lot nicer. The slug can be the primary key, but it doesn’t have to be! It can be anything unique. A lot of times you’ll take something that’s a string like “Riverdale Middle School” and convert it to something URL-friendly, like “riverdale-middle-school.” You’ll save this in a new column called slug and make that be your slug. 5.5.2 Building our detail route To build our detail page, we need a new route. This is going to be a special route, since the end of the URL can change - /schools/X141 is Riverdale, but /schools/X068 is Public School 068. To accomplish this we add a variable into our route. @app.route(&#39;/schools/&lt;slug&gt;&#39;) def detail(slug): school = School.query.filter_by(LOC_CODE=slug).first() return school.SCHOOLNAME Now anything can do into the part after /schools/. If we want to find P.S. 68, we’ll check out http://localhost:5000/schools/X068. And it works! If we want to go line by line, we’ll start with the route. Any variables in the URL - and you can have a million! - are surrounded by angle brackets. These brackets don’t show up in the URL, they just mean “something else is gonna be there.” @app.route(&#39;/schools/&lt;slug&gt;&#39;) When we make our function, we used to always use def hello(), but now our variable shows up in the parentheses. def detail(slug): We then use that slug to filter through the schools (like a WHERE) and take the very first result. Because we used first() SQLAlchemy gives us back one row that we can do things like .SCHOOLNAME on it. If we’d asked for all() instead, we’d have a list that we’d need to loop through (even if there was only one result!). school = School.query.filter_by(LOC_CODE=slug).first() return school.SCHOOLNAME We used return to print the school’s name to the web page, but now it’s time to upgrade to a full-fledged detail page. 5.5.3 Crafting a detail page Before we make our actual detail page, let’s write the code to use the template. Kind of backwards, but let’s do it anyway! Instead of using return with just school.SCHOOLNAME, we’ll ask it to send a new template. We’ll call this template detail.html, and send the school we found in the database, just like we sent the school count to the other template. @app.route(&#39;/schools/&lt;slug&gt;&#39;) def detail(slug): school = School.query.filter_by(LOC_CODE=slug).first() return render_template(&quot;detail.html&quot;, school=school) We’re missing detail.html, but we can fix that! Create a new file called detail.html and paste the following code into it. &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;School page: {{ school.SCHOOLNAME }}&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;nav class=&quot;navbar navbar-expand-lg navbar-dark bg-dark&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Schools&lt;/a&gt; &lt;/nav&gt; &lt;div class=&quot;jumbotron&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1 class=&quot;display-4&quot;&gt;{{ school.SCHOOLNAME }}&lt;/h1&gt; &lt;p class=&quot;lead&quot;&gt;{{ school.ADDRESS }}, {{ school.city }}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; Look at that!!! We can just use `{{ school.column_name }}`` anywhere on the page to fill in details about the school! But… the text itself is kind of ugly, as 4011 MONTICELLO AVENUE, BRONX seems a little TOO MUCH LIKE YELLING FOR MY TASTES. Since our Jinja2 template is Python-based, though, a solution is not far off. Just like we can do .upper() and .lower() on a string to make it ALL CAPS or all lowercase, Python has another fun string manipulator called .title(). Let’s change our address section to look like this: &lt;p class=&quot;lead&quot;&gt;{{ school.ADDRESS.title() }}, {{ school.city.title() }}&lt;/p&gt; You could even change the school.SCHOOLNAME in the same way! It looks beautiful now! 5.6 Linking from the index to the detail page Right now you need to know the specific URL of a school in order to end up on the detail page. But who has time for that?! I think our homepage - our / route - should list all the schools and also include links to each of their detail pages. It’s easy enough! A link in HTML looks like this: &lt;p&gt;&lt;a href=&quot;http://example/states/WA&quot;&gt;Washington&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;http://example/states/VA&quot;&gt;Virginia&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;http://example/states/&quot;&gt;Virginia&lt;/a&gt;&lt;/p&gt; Or rather, a series of links in a series of paragaph tags. Right now if you look at index.html, we’re listing our schools in an almost-similar fashion. {% for school in schools %} &lt;p&gt;{{ school.SCHOOLNAME }}&lt;/p&gt; {% endfor %} If we want to change this to be links, we need to do a fill-in-the-blanks with the href=\"...\", just like we did with the school’s name. {% for school in schools %} &lt;p&gt;&lt;a href=&quot;/schools/{{ school.LOC_CODE }}&quot;&gt;{{ school.SCHOOLNAME }}&lt;/a&gt;&lt;/p&gt; {% endfor %} The href attribute now changes based on which school you’re looking at! Refresh the page and see all those sweet, sweet links. Click on any of them and you’ll be able to go back and forth between the school list and the school detail page. But oh, wait! This is only the schools in a certain ZIP code. If you want to make it be all schools, you need to open up app.py and change a bit of code. Inside of def hello() we’re finding out schools like this: zip_schools = School.query.filter_by(ZIP=&#39;10466&#39;).all() When we should instead do something like this: zip_schools = School.query.all() And, well, calling it zip_schools doesn’t make much sense any more, so let’s rename our variable to just plain schools: schools = School.query.all() return render_template(&quot;index.html&quot;, count=school_count, schools=schools) 5.7 Reusing templates That’s a BIG web page we have now, though! It might make more sense if we had a few smaller web pages, ones where you could find a list of schools in a particular borough/city or zip code (…which we just got rid of). If we look at the dataset, the city column seems like a good place to start. Let’s build a new route called city so people can browse to /city/BRONX and get all of the schools in the Bronx (although for now we’ll just print the number of schools instead of showing a list). @app.route(&#39;/city/&lt;cityname&gt;&#39;) def city(cityname): schools = School.query.filter_by(city=cityname).all() return f&quot;This city has {len(schools)} schools&quot; Take a peek at http://localhost:5000/city/BRONX and be amazed! Note that the school counting text is an f-string, not a Jinja template! I… don’t like that URL. We would much rather have /city/bronx instead of /city/BRONX, right? To fix that up, we just need to take whatever comes in as the search term, capitalize it, and then send it to the database. So if you type bronx or BROnx or bronX or whatever it’ll always be translated to BRONX when you search. @app.route(&#39;/city/&lt;cityname&gt;&#39;) def city(cityname): schools = School.query.filter_by(city=cityname.upper()).all() return f&quot;This city has {len(schools)} schools&quot; Seeing http://localhost:5000/city/bronx is a nicer experience, right? Right. Now that we want to show a list of the schools, you might think it’s time we made yet another template. But what if… we didn’t need to do that? What if we could just re-use another template? Typically you have a handful of templates, and re-use them in different routes (or “views”). Showing all of the schools in a particular zip code and all of the schools in a particular city and all of the schools in generally is practically the same thing, it’s just a list of schools. Right now our index.html template takes a variable called schools and displays all of them. What if we just send the schools for this city on over to that template? @app.route(&#39;/city/&lt;cityname&gt;&#39;) def city(cityname): schools = School.query.filter_by(city=cityname.upper()).all() return render_template(&quot;index.html&quot;, schools=schools) A horrible error!!! We didn’t pass it a count= variable, so when we tried to do this code: There are {{ &quot;{:,}&quot;.format(count) }} schools in New York City. it freaked out and panicked and shut down. An easy fix is to adjust our city route to also send the number of schools to the template - we don’t need to do .count() or anything, we can just stick with a simple len(schools) @app.route(&#39;/city/&lt;cityname&gt;&#39;) def city(cityname): schools = School.query.filter_by(city=cityname.upper()).all() return render_template(&quot;index.html&quot;, schools=schools, count=len(schools)) Hooray! A little better, except http://localhost:5000/city/bronx reads There are 392 schools in New York City., when we’re definitely just trying to look at the Bronx! We don’t need a whole new template for that - we just need to adjust each template to print out where we’re looking, and change our view to send that data. Let’s call it location, and just have it be the city name: @app.route(&#39;/city/&lt;cityname&gt;&#39;) def city(cityname): schools = School.query.filter_by(city=cityname.upper()).all() return render_template(&quot;index.html&quot;, schools=schools, count=len(schools), location=cityname) We’ll make a tiny adjustment in our index.html to use the new variable: &lt;h1 class=&quot;display-4&quot;&gt;There are {{ &quot;{:,}&quot;.format(count) }} schools in {{ location.title() }}.&lt;/h1&gt; and we now have There are 392 schools in Bronx on the top of our page! It also works for Manhattan and Brooklyn, too. The Staten Island link, though, is http://localhost:5000/city/staten island, which is gross and ugly. Our little fix is going to be an extra step beyond .upper() on our city before we search in the database - we’ll also replace all - with spaces. We receive staten-island from the URL staten-island gets the ‘-’ replaced with ’ ’, making staten island staten island gets uppercased into STATEN ISLAND STATEN ISLAND gets searched! @app.route(&#39;/city/&lt;cityname&gt;&#39;) def city(cityname): cityname = cityname.replace(&quot;-&quot;, &quot; &quot;) schools = School.query.filter_by(city=cityname.upper()).all() return render_template(&quot;index.html&quot;, schools=schools, count=len(schools), location=cityname) Beauty! Success! You can try doing it all in the filter_by statement, but then we’ll see “Staten-Island” printed out on the web page. Give it a try if you’d like! 5.7.1 Adding yet another route And what about a route for zip codes? Easy-peasy! WE’ll just make a route called zip and do the exact same thing - same template, just with a different filter. @app.route(&#39;/zip/&lt;zipcode&gt;&#39;) def zip(zipcode): schools = School.query.filter_by(ZIP=zipcode).all() return render_template(&quot;index.html&quot;, schools=schools, count=len(schools), location=zipcode) Look at that! All of six seconds to get a brand new way to browse the schools. 5.7.2 Fixing up the root route Before we jump ahead, there’s one tiny thing we need to fix - our root route! If you visit our homepage http://localhost:5000/ we get a nice big ‘location’ is undefined’ error. This is because we didn’t send a location from our root route, so the template panics when it sees our schools in {{ location.title() }} phrase. The app.py currently looks like this: @app.route(&quot;/&quot;) def hello(): school_count = School.query.count() schools = School.query.all() return render_template(&quot;index.html&quot;, count=school_count, schools=schools) If we don’t have a variable we’re passing in, how do we get a location to give to our template? …we can just use a string! Instead of location=cityname, we can just say location=\"New York City\" and it works just fine. return render_template(&quot;index.html&quot;, count=school_count, schools=schools, location=&quot;New York City&quot;) Voilà! Perfect, amazing, beautiful, and a total dream. 5.8 Cleaning up Let’s clean up a little bit! Remove the shoelaces and about route (if you want an about route later you can always add it back in) Rename our root route function from def hello() to def index(). It doesn’t change anything, really, but it’s a nicer name. Change the navbar on index.html to say Schools instead of An incredible site Rename index.html to list.html (because it’s a list, right?) and change the render_template calls in our index, city and zipcode routes. 5.8.1 Our code Overall, our Python code should now look like this: # app.py from flask import Flask from flask import render_template from flask_sqlalchemy import SQLAlchemy app = Flask(__name__) app.config[&#39;SQLALCHEMY_DATABASE_URI&#39;] = &#39;sqlite:///schools.sqlite3&#39; db = SQLAlchemy(app) db.Model.metadata.reflect(db.engine) class School(db.Model): __tablename__ = &#39;schools-geocoded&#39; __table_args__ = { &#39;extend_existing&#39;: True } LOC_CODE = db.Column(db.Text, primary_key=True) @app.route(&#39;/schools/&lt;slug&gt;&#39;) def detail(slug): school = School.query.filter_by(LOC_CODE=slug).first() return render_template(&quot;detail.html&quot;, school=school) @app.route(&#39;/zip/&lt;zipcode&gt;&#39;) def zip(zipcode): schools = School.query.filter_by(ZIP=zipcode).all() return render_template(&quot;list.html&quot;, schools=schools, count=len(schools), location=zipcode) @app.route(&#39;/city/&lt;cityname&gt;&#39;) def city(cityname): cityname = cityname.replace(&quot;-&quot;, &quot; &quot;) schools = School.query.filter_by(city=cityname.upper()).all() return render_template(&quot;list.html&quot;, schools=schools, count=len(schools), location=cityname) @app.route(&quot;/&quot;) def index(): school_count = School.query.count() schools = School.query.all() return render_template(&quot;list.html&quot;, count=school_count, schools=schools, location=&quot;New York City&quot;) if __name__ == &#39;__main__&#39;: app.run(debug=True) Our list.html should look like this: &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;My incredible web site.&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;nav class=&quot;navbar navbar-expand-lg navbar-dark bg-dark&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Schools&lt;/a&gt; &lt;/nav&gt; &lt;div class=&quot;jumbotron&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1 class=&quot;display-4&quot;&gt;There are {{ &quot;{:,}&quot;.format(count) }} schools in {{ location.title() }}.&lt;/h1&gt; &lt;p class=&quot;lead&quot;&gt;It&#39;s pretty cool.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt;I&#39;m amazed and frankly you should be, too.&lt;/p&gt; {% for school in schools %} &lt;p&gt;&lt;a href=&quot;/schools/{{ school.LOC_CODE }}&quot;&gt;{{ school.SCHOOLNAME }}&lt;/a&gt;&lt;/p&gt; {% endfor %} &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; "],
["leveling-up-with-advanced-sqlalchemy-queries.html", "6 Leveling up with advanced SQLAlchemy queries 6.1 Listing all of our cities", " 6 Leveling up with advanced SQLAlchemy queries Okay, these might not be advanced, but there’s going to help us a lot. 6.1 Listing all of our cities First, it isn’t going to do us much good to say “hey, browse by cities!” if we don’t let everyone know what the options are for cities. The code below selects all of the distinct city column values from the School model, and then lets us view them. AFter you add the route and cities.html (below), you can see it at work if you visit http://localhost:5000/city. @app.route(&#39;/city&#39;) def city_list(): # Get the unique city values from the database cities = School.query.with_entities(School.city).distinct().all() # They&#39;re in a weird list of one-element lists, though, like # [[&#39;Yonkers&#39;],[&#39;Brooklyn&#39;],[&#39;Manhattan&#39;]] # so we&#39;ll take them out of that cities = [city[0] for city in cities] return render_template(&quot;cities.html&quot;, cities=cities) Documentation for Flask-SQLAlchemy is… not ideal, I found out how to do the distinct-columns thing here Your cities.html should look like this: &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Schools&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;nav class=&quot;navbar navbar-expand-lg navbar-dark bg-dark&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Schools&lt;/a&gt; &lt;/nav&gt; &lt;div class=&quot;jumbotron&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1 class=&quot;display-4&quot;&gt;Cities&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;container&quot;&gt; {% for city in cities %} &lt;p&gt;{{ city }}&lt;/p&gt; {% endfor %} &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; There we go, all of our cities listed out on a nice page, ready to go. Of course we’d like to have them printed out nicely (not ALL CAPS LIKE THAT), and each city name link ot the page of schools. To add that, we’ll adjust our {{ city }} disply a little bit. {% for city in cities %} &lt;p&gt;&lt;a href=&quot;/city/{{ city }}&quot;&gt;{{ city.title() }}&lt;/a&gt;&lt;/p&gt; {% endfor %} 6.1.1 Cleaning text in our Jinja2 templates If you click a few of the links, you’ll notice that it’s sending everyone to /city/YONKERS and /city/STATEN ISLAND. We didn’t spend so much time letting /city/yonkers and /city/staten-island work to give up and let this happen! Our fix is ugly, but it works: &lt;p&gt;&lt;a href=&quot;/city/{{ city.lower().replace(&#39; &#39;, &#39;-&#39;) }}&quot;&gt;{{ city.title() }}&lt;/a&gt;&lt;/p&gt; 6.1.2 No wait, maybe not! You might notice that “New York” appears twice in our list. It’s because sometimes it’s NEW YORK in our database, while sometimes it’s New York. We could edit our database and fix it, but it’s usually easy to just handle bad data elegantly and remove them in our app. Usually to remove duplicates, you’d use something like list(set(cities)), which is code that everyone blindly uses without understanding it. But hey, it doesn’t matter if you understand it: it removes duplicates! The problem with this code is it only removes exact matches, and since one city is NEW YORK and one is New York it won’t work just yet. We need to standardize first, then remove duplicates. So our app.py gets edited as such: @app.route(&#39;/city&#39;) def city_list(): # Get the unique city values from the database cities = School.query.with_entities(School.city).distinct().all() # ...more notes I&#39;m hiding... # Convert to titlecase while we&#39;re pulling out of the weird list thing cities = [city[0].title() for city in cities] # Now that they&#39;re both &quot;New York,&quot; we can now dedupe and sort cities = sorted(list(set(cities))) return render_template(&quot;cities.html&quot;, cities=cities) And, if you noticed, we sorted them while we were at it! Beautiful work. What a nice page. 6.1.3 Doing the same for ZIP codes I trust that we can do this without guidance now! You need new route and a new template. "],
["layouts-for-our-templates.html", "7 Layouts for our templates 7.1 Layouts 7.2 Adding in our navigation", " 7 Layouts for our templates Now that we have a handful of templates - list.html, detail.html, cities.html, and maybe some more if you did the zipcodes thing - we’re going to want to get a little more organized. I’ve been thinking about adding some links to the navigation up at the top of the page so visitors can browse between different pages. One link for the cities page, one for the ZIP codes page, one for the home page, etc etc etc. The problem is that I’m lazy, and there’s at least three different pages to edit. As our site grows and grows, we’re going to have more templates and mote things to edit and I don’t want to edit seventeen HTML pages every time I want to make one change to the header or footer. 7.1 Layouts Layouts are separate HTML pages that might have a header and a footer, but nothing in the middle. When we use our template, we say “hey! go find that layout, and wrap me in its warm embrace.” And thus our template automatically gets the header and footer! Let’s try a test with one of our schools. First, edit detail.html to remove everything outside of the bits that are about the school (or will eventually be about the school). It should look like this: &lt;div class=&quot;jumbotron&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1 class=&quot;display-4&quot;&gt;{{ school.SCHOOLNAME.title() }}&lt;/h1&gt; &lt;p class=&quot;lead&quot;&gt;{{ school.ADDRESS.title() }}, {{ school.city.title() }}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; If you visit http://localhost:5000/schools/X068 now, you’ll be horrified. All of our hard work! But let’s go and make a new file in the same templates folder called layout.html. &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;My incredible web site.&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;nav class=&quot;navbar navbar-expand-lg navbar-dark bg-dark&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Schools&lt;/a&gt; &lt;/nav&gt; {% block content %}{% endblock %} &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; It’s everything from our previous page we got rid of, but with the addition of {% block content %}{% endblock %}. That little piece means “if you have a chunk of code you call content, I’ll put it here.” Refresh http://localhost:5000/schools/X068, note that nothing’s changed, and realize we need to Tell our detail.html to call the layout Identify the parts of detail.html that should be the content To tell the template to use a layout, you put a {% extends \"layout.html\" %} up top. Then you use that weird {% block... thing again to identify where the content is. Our updated detail.html will look like this: {% extends &#39;layout.html&#39; %} {% block content %} &lt;div class=&quot;jumbotron&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1 class=&quot;display-4&quot;&gt;{{ school.SCHOOLNAME.title() }}&lt;/h1&gt; &lt;p class=&quot;lead&quot;&gt;{{ school.ADDRESS.title() }}, {{ school.city.title() }}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; {% endblock %} Pretty fun, right? Amazingly fun? Incredibly fun? And it gets even better! Every single one of our pages has that “jumbotron” thing in it, with the big text and the small text. Sometimes it’s a title like “Cities” or sometimes “P.S. 068 Bronx” or sometimes the count of the schools in a zip code. What happens if we wanted to change the style of our big headers, and replace the jumbotron with something a little more elegant? Well, we’d have to go through and edit every one of those pages with the new style, which wouldn’t be fun at all. With our current template, we called everything on the page content, which then filled in the content section of layout.html. But it doesn’t have to be that way! What if we had more sections, things like headline and subhead and anything else we could think of? Your detail.html might look like this, with headline and subhead sections: {% extends &#39;layout.html&#39; %} {% block headline %} {{ school.SCHOOLNAME.title() }} {% endblock %} {% block subhead %} {{ school.ADDRESS.title() }}, {{ school.city.title() }} {% endblock %} {% block content %} &lt;div class=&quot;container&quot;&gt; &lt;p&gt;&lt;strong&gt;School type:&lt;/strong&gt; {{ school.SCH_TYPE }}&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; {% endblock %} Which then get imported into our layout.html: &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;My incredible web site.&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;nav class=&quot;navbar navbar-expand-lg navbar-dark bg-dark&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Schools&lt;/a&gt; &lt;/nav&gt; &lt;div class=&quot;jumbotron&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1 class=&quot;display-4&quot;&gt;{% block headline %}{% endblock %}&lt;/h1&gt; &lt;p class=&quot;lead&quot;&gt;{% block subhead %}{% endblock %}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; {% block content %}{% endblock %} &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; I added the school type just so we could be sure that content was filled in. Now we can go through each of our other pages and do the same thing, using the layout and breaking the content into headline, subhead and content sections. Our list.html file gets chunked up like this: {% extends &#39;layout.html&#39; %} {% block headline %} There are {{ &quot;{:,}&quot;.format(count) }} schools in {{ location.title() }} {% endblock %} {% block subhead %} It&#39;s pretty cool. {% endblock %} {% block content %} &lt;div class=&quot;container&quot;&gt; &lt;p&gt;I&#39;m amazed and frankly you should be, too.&lt;/p&gt; {% for school in schools %} &lt;p&gt;&lt;a href=&quot;/schools/{{ school.LOC_CODE }}&quot;&gt;{{ school.SCHOOLNAME }}&lt;/a&gt;&lt;/p&gt; {% endfor %} &lt;/div&gt; {% endblock %} And in city.html we don’t have a subhead, so we can go ahead and completely ignore it: {% extends &#39;layout.html&#39; %} {% block headline %} Cities {% endblock %} {% block content %} &lt;div class=&quot;container&quot;&gt; {% for city in cities %} &lt;p&gt;&lt;a href=&quot;/city/{{ city.lower().replace(&#39; &#39;, &#39;-&#39;) }}&quot;&gt;{{ city.title() }}&lt;/a&gt;&lt;/p&gt; {% endfor %} &lt;/div&gt; {% endblock %} 7.1.1 And a final fun trick If you pay attention to the top of your browser, the title of the page, you’ll notice it’s always the same - “My incredible web site.” That’s both useless and narcissistic, so it’d be great to change it. A benefit of having moved to a template with variables for things like the header, subhead and content, is that we can re-use the headline in both the jumbotron and* the title of the page. Unfortunately, Jinja2 is really weird, so we can’t just use the {% block... syntax again. Instead, we do this: &lt;head&gt; &lt;title&gt;{{ self.headline() }}&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;/head&gt; If self.headline() gets the headline, why don’t we use that all the time instead of the werid {% block... syntax? I have no idea, I just follow directions. Visit a few different pages and rejoice! Titles galore. 7.2 Adding in our navigation I almost forgot why we were doing this! Navigation, navigation, navigation. Let’s go ahead and edit our layout to add a new link to the header, following the instructions from Bootstrap. Edit the &lt;nav&gt; section of layout.html like so: &lt;nav class=&quot;navbar navbar-expand-lg navbar-dark bg-dark&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;/&quot;&gt;Schools&lt;/a&gt; &lt;ul class=&quot;navbar-nav&quot;&gt; &lt;li class=&quot;nav-item active&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/&quot;&gt;Home&lt;/span&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/city&quot;&gt;Cities&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; Navs in Bootstrap are pretty fancy beasts, you can read the docs for more info. 7.2.1 A dropdown for cities We don’t have that many cities, right? Why can’t we just have a dropdown that lists them all? If you want to go that route, I recommend checking out context processors on the FLask end and navigation dropdowns on Bootstrap. You’ll also need to add the Bootstrap JavaScript to make them work, which you can find on their homepage under the BootstrapCDN heading. "],
["mapping-our-schools.html", "8 Mapping our schools 8.1 Adding MapBox to our pages", " 8 Mapping our schools We’re going to map our schools with MapBox GL. Once upon a time we would have used Leaflet, but the world has since moved on to newer and (arguably) better things. 8.1 Adding MapBox to our pages 8.1.1 Adding MapBox CSS and JS MapBox uses special CSS and JavaScript to work. Since we aren’t sure which pages we’ll be using it on, we might as well just add it to our universal layout. Edit the &lt;head&gt; section of layout.html to match this: &lt;head&gt; &lt;title&gt;{{ self.headline() }}&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;script src=&#39;https://api.tiles.mapbox.com/mapbox-gl-js/v1.0.0/mapbox-gl.js&#39;&gt;&lt;/script&gt; &lt;link href=&#39;https://api.tiles.mapbox.com/mapbox-gl-js/v1.0.0/mapbox-gl.css&#39; rel=&#39;stylesheet&#39; /&gt; &lt;/head&gt; Now every single page will be able to use the ultimate magic power of MapBox! 8.1.2 Adding a basic (and fake) map Now we’ll open up detail.html and add the sample MapBox map from their documentation in the content block. {% block content %} &lt;div class=&quot;container&quot;&gt; &lt;div id=&#39;map&#39; style=&#39;width: 400px; height: 300px;&#39;&gt;&lt;/div&gt; &lt;script&gt; mapboxgl.accessToken = &#39;pk.eyJ1IjoianNvbWEiLCJhIjoibFJmYl9JWSJ9.AUm8d76cbOvVEn2mMeG_ZA&#39;; var map = new mapboxgl.Map({ container: &#39;map&#39;, style: &#39;mapbox://styles/mapbox/streets-v9&#39; }); map.on(&#39;load&#39;, function() { var geojsonData = { &quot;type&quot;: &quot;FeatureCollection&quot;, &quot;features&quot;: [{ &quot;type&quot;: &quot;Feature&quot;, &quot;geometry&quot;: { &quot;type&quot;: &quot;Point&quot;, &quot;coordinates&quot;: [0, 0] } }] }; map.addLayer({ &quot;id&quot;: &quot;points&quot;, &quot;type&quot;: &quot;circle&quot;, &quot;source&quot;: { &quot;type&quot;: &quot;geojson&quot;, &quot;data&quot;: geojsonData } }) }) &lt;/script&gt; &lt;p&gt;&lt;strong&gt;School type:&lt;/strong&gt; {{ school.SCH_TYPE }}&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; {% endblock %} Refresh the page and YOU HAVE A MAP! A terrible, horrible map, with a circle in no meaningful position, but a map regardless. Let’s look at what each part of this new code does. &lt;div id=&#39;map&#39; style=&#39;width: 400px; height: 300px;&#39;&gt;&lt;/div&gt; This code makes an empty box on your page. An &lt;h1&gt; is a headline and a &lt;p&gt; is a paragraph, but a &lt;div&gt; doesn’t really mean anything. This is going to be eventually filled up with your map. Right now it’s being set to 400 pixels wide and 300 pixels tall. mapboxgl.accessToken = &#39;pk.eyJ1IjoianNvbWEiLCJhIjoibFJmYl9JWSJ9.AUm8d76cbOvVEn2mMeG_ZA&#39;; var map = new mapboxgl.Map({ container: &#39;map&#39;, style: &#39;mapbox://styles/mapbox/streets-v9&#39; }); This is where we initialize MapBox GL. In order to display the background of your map - called the basemap, you need to tell MapBox who you are (if you use a LOT of pageviews, they’ll start charging you). That’s what mapboxgl.accessToken is doing. We’re using the access token from their demo, so it shouldn’t be a problem. The next few lines are setting up the map &lt;div&gt; that we made a little earlier, and telling MapBox what style we want the background map to be. We then use map.on('load')... to wait for the map to load. Once it’s ready we start to assemble our data. var geojsonData = { &quot;type&quot;: &quot;FeatureCollection&quot;, &quot;features&quot;: [{ &quot;type&quot;: &quot;Feature&quot;, &quot;geometry&quot;: { &quot;type&quot;: &quot;Point&quot;, &quot;coordinates&quot;: [0, 0] } }] }; MapBox GL uses a data format called GeoJSON to keep track of points, lines, shapes and such. You can play around with it at geojson.io, but the basic idea is that a single point or line or shape or watever is called a Feature and a bunch of features is called a FeatureCollection. In this case we have exactly one feature, and it’s a Point with coordinates at a latitude and longitude of [0, 0]. Next up we need to actually give that data to our map so it can draw the point. map.addLayer({ &quot;id&quot;: &quot;points&quot;, &quot;type&quot;: &quot;circle&quot;, &quot;source&quot;: { &quot;type&quot;: &quot;geojson&quot;, &quot;data&quot;: geojsonData } }) We’re using addLayer to attach our geojsonData to our map. You can tell all sorts of stuff to your map, from styling and interaction, but we’re just saying “hey, this is a bunch of circles, draw some circles.” Not very exciting, but it gets the job done. 8.1.3 Inserting our data into the map The map is drawing a circle in the middle of the ocean because of these lines here: &quot;geometry&quot;: { &quot;type&quot;: &quot;Point&quot;, &quot;coordinates&quot;: [0, 0] } The point says it’s at [0, 0], and so the map draws it there. If we adjust the first number a little bit, we’ll see it jump to the right! &quot;geometry&quot;: { &quot;type&quot;: &quot;Point&quot;, &quot;coordinates&quot;: [30, 0] } All we need to do is put the latitude and longitude of the school into those coordinates, and we’ll be all set! The confusing thing about this is that while this code is definitely JavaScript, we get to treat it just like HTML or anything else we’ve been using {{ }} with. Since our school has a longitude column and a latitude column, we can pop them right into the coordinates, and the circle will move right on along with them: &quot;geometry&quot;: { &quot;type&quot;: &quot;Point&quot;, &quot;coordinates&quot;: [{{ school.longitude }}, {{ school.latitude }}] } If you view the source of the page, you can see how the longitude and latitude of your school just got dropped in. &quot;geometry&quot;: { &quot;type&quot;: &quot;Point&quot;, &quot;coordinates&quot;: [-73.95471, 40.726437] } You didn’t have to do any JavaScript coding, you just said “hey, Jinja2 template, insert the Python variable’s coordinates exacty where I tell you.” It’s kind of weird to be using Python variables on an HTML page in a JavaScript section but hey, if it works it works! 8.1.4 Zooming and centering If we visited a few dozen of our school pages, we’d notice they all seem to be in the same place. That’s because we’re zoomed way out in the middle of nowhere! Let’s start by centering our map on New York City. Its coordinates are roughly , so when we start up the map we can tell it exactly were to be. We’ll also zoom in a bit, just to frame the bounds of city nicely. mapboxgl.accessToken = &#39;pk.eyJ1IjoianNvbWEiLCJhIjoibFJmYl9JWSJ9.AUm8d76cbOvVEn2mMeG_ZA&#39;; var map = new mapboxgl.Map({ container: &#39;map&#39;, style: &#39;mapbox://styles/mapbox/streets-v9&#39;, center: [-74, 40.71], zoom: 9 }); Be sure to add a , at the end of the style: line, or JavaScript will get unhappy and break! 8.1.5 Adjusting the style of our dot Now that we’re zoomed in a bit I’m a little less happy with our black dot - it doesn’t stand out as well as I thought! If we want to play around with the style of the circle, we’ll do it by adding a paint option to our addLayer call: map.addLayer({ &quot;id&quot;: &quot;points&quot;, &quot;type&quot;: &quot;circle&quot;, &quot;source&quot;: { &quot;type&quot;: &quot;geojson&quot;, &quot;data&quot;: geojsonData }, &quot;paint&quot;: { &quot;circle-radius&quot;: 5, &quot;circle-color&quot;: &quot;#ECCB2F&quot;, &quot;circle-stroke-width&quot;: 1, &quot;circle-stroke-color&quot;: &quot;black&quot; } }) I set the circle radius to be a bit larger, gave it a fill color (using an HTML color code) and a little stroke (aka border) to make the circle stand out a bit more. If we’re still not satisfied, we can play around with the style of the background - it’s easier to stand out if you’re on something lighter, right? To make this happen, you can adjust the initial map call to start with a different style. mapboxgl.accessToken = &#39;pk.eyJ1IjoianNvbWEiLCJhIjoibFJmYl9JWSJ9.AUm8d76cbOvVEn2mMeG_ZA&#39;; var map = new mapboxgl.Map({ container: &#39;map&#39;, style: &#39;mapbox://styles/mapbox/light-v10&#39;, center: [-74, 40.71], zoom: 9 }); "],
["reorganizing-our-page-with-columns.html", "9 Reorganizing our page with columns 9.1 Columns and rows", " 9 Reorganizing our page with columns Before we do anything, we need to get some of that map JavaScript out of the way so we can just deal with nice, clean HTML. Reoganize your details.html to push the &lt;script&gt; tag under the end of the container. That way we can push around the map and the school details and everything without accidentally breaking the JavaScript. {% block content %} &lt;div class=&quot;container&quot;&gt; &lt;div id=&#39;map&#39; style=&#39;width: 400px; height: 300px;&#39;&gt;&lt;/div&gt; &lt;p&gt;&lt;strong&gt;School type:&lt;/strong&gt; {{ school.SCH_TYPE }}&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; mapboxgl.accessToken = &#39;pk.eyJ1IjoianNvbWEiLCJhIjoibFJmYl9JWSJ9.AUm8d76cbOvVEn2mMeG_ZA&#39;; var map = new mapboxgl.Map({ container: &#39;map&#39;, style: &#39;mapbox://styles/mapbox/light-v10&#39;, center: [-74, 40.71], zoom: 9 }); map.on(&#39;load&#39;, function() { var geojsonData = { &quot;type&quot;: &quot;FeatureCollection&quot;, &quot;features&quot;: [{ &quot;type&quot;: &quot;Feature&quot;, &quot;geometry&quot;: { &quot;type&quot;: &quot;Point&quot;, &quot;coordinates&quot;: [{{ school.longitude }}, {{ school.latitude }}] } }] }; map.addLayer({ &quot;id&quot;: &quot;points&quot;, &quot;type&quot;: &quot;circle&quot;, &quot;source&quot;: { &quot;type&quot;: &quot;geojson&quot;, &quot;data&quot;: geojsonData }, &quot;paint&quot;: { &quot;circle-radius&quot;: 5, &quot;circle-color&quot;: &quot;#ECCB2F&quot;, &quot;circle-stroke-width&quot;: 1, &quot;circle-stroke-color&quot;: &quot;black&quot; } }) }) &lt;/script&gt; {% endblock %} 9.1 Columns and rows The layout system of Bootstrap is organized using (very wordy) columns and rows. You can read more here, but what we’re going to do below is break our content into two columns - data on the left, map on the right. &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col&quot;&gt; &lt;p&gt;&lt;strong&gt;School type:&lt;/strong&gt; {{ school.SCH_TYPE }}&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;div id=&#39;map&#39; style=&#39;width: 100%; height: 300px;&#39;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; If you’d like mor edetails about how this works, read up on the Bootstrap grid system. "]
]
